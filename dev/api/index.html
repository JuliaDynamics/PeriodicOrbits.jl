<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Public API · PeriodicOrbits.jl</title><meta name="title" content="The Public API · PeriodicOrbits.jl"/><meta property="og:title" content="The Public API · PeriodicOrbits.jl"/><meta property="twitter:title" content="The Public API · PeriodicOrbits.jl"/><meta name="description" content="Documentation for PeriodicOrbits.jl."/><meta property="og:description" content="Documentation for PeriodicOrbits.jl."/><meta property="twitter:description" content="Documentation for PeriodicOrbits.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PeriodicOrbits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PeriodicOrbits.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>The Public API</a><ul class="internal"><li><a class="tocitem" href="#Main-functions"><span>Main functions</span></a></li><li><a class="tocitem" href="#Algorithms-for-Discrete-Time-Systems"><span>Algorithms for Discrete-Time Systems</span></a></li><li><a class="tocitem" href="#Algorithms-for-Continuous-Time-Systems"><span>Algorithms for Continuous-Time Systems</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li><li><a class="tocitem" href="#Adding-new-algorithms"><span>Adding new algorithms</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Public-API"><a class="docs-heading-anchor" href="#The-Public-API">The Public API</a><a id="The-Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-Public-API" title="Permalink"></a></h1><h2 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.periodic_orbit" href="#PeriodicOrbits.periodic_orbit"><code>PeriodicOrbits.periodic_orbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodic_orbit(ds::DynamicalSystem, alg::PeriodicOrbitFinder [, ig::InitialGuess]) → PeriodicOrbit</code></pre><p>Try to find a single periodic orbit of the dynamical system <code>ds</code> using the algorithm <code>alg</code> and optionally given some <a href="#PeriodicOrbits.InitialGuess"><code>InitialGuess</code></a> <code>ig</code> which defaults to <code>InitialGuess(ds)</code>. Return the result as a <a href="#PeriodicOrbits.PeriodicOrbit"><code>PeriodicOrbit</code></a>.</p><p>Depending on <code>alg</code>, it is not guaranteed that a periodic orbit will be found given <code>ds, ig</code>. If one is not found, <code>nothing</code> is returned instead.</p><p>For more details on the periodic orbit detection algorithm, see the documentation the <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L89-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.periodic_orbits" href="#PeriodicOrbits.periodic_orbits"><code>PeriodicOrbits.periodic_orbits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodic_orbits(ds::DynamicalSystem, alg::PeriodicOrbitFinder [, igs]::Vector{InitialGuess} = InitialGuess(ds)) → Vector{PeriodicOrbit}</code></pre><p>Try to find multiple periodic orbits of the dynamical system <code>ds</code> using the algorithm <code>alg</code> and optionally given a <code>Vector</code> of initial guesses which defaults to <code>[InitialGuess(ds)]</code>. given some initial guesses <code>igs</code>. Return the result as a <code>Vector</code> of <a href="#PeriodicOrbits.PeriodicOrbit"><code>PeriodicOrbit</code></a>.</p><p>This function exists because some algorithms optimize/specialize on detecting multiple periodic orbits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.PeriodicOrbitFinder" href="#PeriodicOrbits.PeriodicOrbitFinder"><code>PeriodicOrbits.PeriodicOrbitFinder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicOrbitFinder</code></pre><p>Supertype for all the periodic orbit detection algorithms. Each of the concrete subtypes of <code>PeriodicOrbitFinder</code> represents one given algorithm for detecting periodic orbits. This subtype includes all the necessary metaparameters for the algorithm to work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.InitialGuess" href="#PeriodicOrbits.InitialGuess"><code>PeriodicOrbits.InitialGuess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitialGuess</code></pre><p>A structure that contains an initial guess for a periodic orbit detection algorithms.</p><ul><li><code>u0::AbstractArray{&lt;:Real}</code> - guess of a point in the periodic orbit</li><li><code>T::Union{Real, Nothing}</code> - guess of period of the orbit. Some algorithms do not require the period guess to be given, in which case <code>T</code> is set to <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.PeriodicOrbit" href="#PeriodicOrbits.PeriodicOrbit"><code>PeriodicOrbits.PeriodicOrbit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicOrbit</code></pre><p>A structure that contains information about a periodic orbit.</p><ul><li><code>points::StateSpaceSet</code> - points of the periodic orbit. This container always holds the complete orbit (in the sense of being continuously sampled with some sampling <code>Δt</code> for continuous time systems).</li><li><code>T::Real</code> - the period of the orbit</li><li><code>stable::Union{Bool, Missing}</code> - local stability of the periodic orbit. If the stability is unknown (not computed automatically by an algorithm), this is set to <code>missing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L32-L44">source</a></section></article><h2 id="Algorithms-for-Discrete-Time-Systems"><a class="docs-heading-anchor" href="#Algorithms-for-Discrete-Time-Systems">Algorithms for Discrete-Time Systems</a><a id="Algorithms-for-Discrete-Time-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-for-Discrete-Time-Systems" title="Permalink"></a></h2><ul><li><a href="#PeriodicOrbits.SchmelcherDiakonos"><code>SchmelcherDiakonos</code></a></li><li><a href="#PeriodicOrbits.DavidchackLai"><code>DavidchackLai</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.SchmelcherDiakonos" href="#PeriodicOrbits.SchmelcherDiakonos"><code>PeriodicOrbits.SchmelcherDiakonos</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SchmelcherDiakonos(; kwargs...)</code></pre><p>Detect periodic orbits of <code>ds &lt;: DiscreteTimeDynamicalSystem</code> using algorithm proposed by Schmelcher &amp; Diakonos (<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>o</code> : period of the periodic orbit</li><li><code>λs</code> : vector of λ parameters, see (<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>) for details</li><li><code>indss</code> : vector of vectors of indices for the permutation matrix</li><li><code>signss</code> : vector of vectors of signs for the permutation matrix</li><li><code>maxiters=10000</code> : maximum amount of iterations an initial guess will be iterated before  claiming it has not converged</li><li><code>inftol=10.0</code> : if a state reaches <code>norm(state) ≥ inftol</code> it is assumed that it has  escaped to infinity (and is thus abandoned)</li><li><code>disttol=1e-10</code> : distance tolerance. If the 2-norm of a previous state with the next one  is <code>≤ disttol</code> then it has converged to a fixed point</li></ul><p><strong>Description</strong></p><p>The algorithm used can detect periodic orbits by turning fixed points of the original map <code>ds</code> to stable ones, through the transformation</p><p class="math-container">\[\mathbf{x}_{n+1} = \mathbf{x}_n +
\mathbf{\Lambda}_k\left(f^{(o)}(\mathbf{x}_n) - \mathbf{x}_n\right)\]</p><p>The index <span>$k$</span> counts the various possible <span>$\mathbf{\Lambda}_k$</span>.</p><p><strong>Performance notes</strong></p><p><em>All</em> initial guesses are evolved for <em>all</em> <span>$\mathbf{\Lambda}_k$</span> which can very quickly lead to long computation times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/algorithms/discrete_time/schmelcher_diakonos.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.lambdamatrix" href="#PeriodicOrbits.lambdamatrix"><code>PeriodicOrbits.lambdamatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lambdamatrix(λ, inds::Vector{Int}, sings) -&gt; Λk</code></pre><p>Return the matrix <span>$\mathbf{\Lambda}_k$</span> used to create a new dynamical system with some unstable fixed points turned to stable in the algorithm <a href="#PeriodicOrbits.SchmelcherDiakonos"><code>SchmelcherDiakonos</code></a>.</p><p><strong>Arguments</strong></p><ol><li><code>λ&lt;:Real</code> : the multiplier of the <span>$C_k$</span> matrix, with <code>0 &lt; λ &lt; 1</code>.</li><li><code>inds::Vector{Int}</code> : The <code>i</code>-th entry of this vector gives the <em>row</em> of the nonzero element of the <code>i</code>th column of <span>$C_k$</span>.</li><li><code>sings::Vector{&lt;:Real}</code> : The element of the <code>i</code>-th column of <span>$C_k$</span> is +1 if <code>signs[i] &gt; 0</code> and -1 otherwise (<code>sings</code> can also be <code>Bool</code> vector).</li></ol><p>Calling <code>lambdamatrix(λ, D::Int)</code> creates a random <span>$\mathbf{\Lambda}_k$</span> by randomly generating an <code>inds</code> and a <code>signs</code> from all possible combinations. The <em>collections</em> of all these combinations can be obtained from the function <a href="#PeriodicOrbits.lambdaperms"><code>lambdaperms</code></a>.</p><p><strong>Description</strong></p><p>Each element of <code>inds</code> <em>must be unique</em> such that the resulting matrix is orthogonal and represents the group of special reflections and permutations.</p><p>Deciding the appropriate values for <code>λ, inds, sings</code> is not trivial. However, in ref.(<a href="../references/#Pingel2000">Pingel <em>et al.</em>, 2000</a>) there is a lot of information that can help with that decision. Also, by appropriately choosing various values for <code>λ</code>, one can sort periodic orbits from e.g. least unstable to most unstable, see (<a href="../references/#Diakonos1998">Diakonos <em>et al.</em>, 1998</a>) for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/algorithms/discrete_time/lambdamatrix.jl#L9-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.lambdaperms" href="#PeriodicOrbits.lambdaperms"><code>PeriodicOrbits.lambdaperms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lambdaperms(D) -&gt; indperms, singperms</code></pre><p>Return two collections that each contain all possible combinations of indices (total of <span>$D!$</span>) and signs (total of <span>$2^D$</span>) for dimension <code>D</code> (see <a href="#PeriodicOrbits.lambdamatrix"><code>lambdamatrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/algorithms/discrete_time/lambdamatrix.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.DavidchackLai" href="#PeriodicOrbits.DavidchackLai"><code>PeriodicOrbits.DavidchackLai</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DavidchackLai(; kwargs...)</code></pre><p>Find periodic orbits <code>fps</code> of periods <code>1</code> to <code>n+1</code> for the dynamical system <code>ds</code> using the algorithm propesed by Davidchack &amp; Lai (<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>n::Int64</code> : Periodic orbits of period up to <code>n</code> will be detected. Some (but not all) POs  of period <code>n+1</code> will be detected. Keyword argument <code>n</code> must be a positive integer.</li><li><code>m::Int64</code> : Initial guesses will be used to find POs of period <code>1</code> to <code>m</code>. These  periodic orbits will then be used to detect periodic orbits of periods from <code>m+1</code> to  <code>n+1</code>. Keyword argument <code>m</code> must be a positive integer between <code>1</code> and <code>n</code>.</li><li><code>β = nothing</code>: If it is nothing, then <code>β(n) = 10*1.2^n</code>. Otherwise can be a  function that takes period <code>n</code> and return a number. It is a parameter mentioned  in the paper(<a href="../references/#Davidchack1999">Davidchack and Lai, 1999</a>).</li><li><code>maxiters = nothing</code>: If it is nothing, then initial condition will be iterated <code>max(100, 4*β(p))</code> times (where <code>p</code> is the period of the periodic orbit)  before claiming it has not converged. If it is an integer, then it is the maximum  amount of iterations an initial condition will be iterated before claiming  it has not converged.</li><li><code>disttol = 1e-10</code>: Distance tolerance. If <code>norm(f^{n}(x)-x) &lt; disttol</code>  where <code>f^{n}</code> is the <code>n</code>-th iterate of the dynamic rule <code>f</code>, then <code>x</code>  is an <code>n</code>-periodic point.</li><li><code>abstol = 1e-8</code>: A detected periodic point isn&#39;t stored if it is in <code>abstol</code>  neighborhood of some previously detected point. Distance is measured by  euclidian norm. If you are getting duplicate periodic points, increase this value.</li></ul><p><strong>Description</strong></p><p>The algorithm is an extension of Schmelcher &amp; Diakonos(<a href="../references/#Schmelcher1997">Schmelcher and Diakonos, 1997</a>) implemented as <a href="#PeriodicOrbits.SchmelcherDiakonos"><code>SchmelcherDiakonos</code></a>.</p><p>The algorithm can detect periodic orbits by turning fixed points of the original dynamical system <code>ds</code> to stable ones, through the transformation</p><p class="math-container">\[\mathbf{x}_{n+1} = \mathbf{x}_{n} +
[\beta |g(\mathbf{x}_{n})| C^{T} - J(\mathbf{x}_{n})]^{-1} g(\mathbf{x}_{n})\]</p><p>where</p><p class="math-container">\[g(\mathbf{x}_{n}) = f^{n}(\mathbf{x}_{n}) - \mathbf{x}_{n}\]</p><p>and</p><p class="math-container">\[J(\mathbf{x}_{n}) = \frac{\partial g(\mathbf{x}_{n})}{\partial \mathbf{x}_{n}}\]</p><p>The main difference between <a href="#PeriodicOrbits.SchmelcherDiakonos"><code>SchmelcherDiakonos</code></a> and <a href="#PeriodicOrbits.DavidchackLai"><code>DavidchackLai</code></a> is that the latter uses periodic points of previous period as seeds to detect periodic points of the next period. Additionally, <a href="#PeriodicOrbits.SchmelcherDiakonos"><code>SchmelcherDiakonos</code></a> only detects periodic points of a given period, while <code>davidchacklai</code> detects periodic points of all periods up to <code>n</code>.</p><p><strong>Important note</strong></p><p>For low periods <code>n</code> circa less than 6, you should select <code>m = n</code> otherwise the algorithm won&#39;t detect periodic orbits correctly. For higher periods, you can select <code>m</code> as 6. We recommend experimenting with <code>m</code> as it may depend on the specific problem. Increase <code>m</code> in case the orbits are not being detected correctly.</p><p>Initial guesses for this algorithm can be selected as a uniform grid of points in the state space or subset of a chaotic trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/algorithms/discrete_time/davidchack_lai.jl#L5-L71">source</a></section></article><h2 id="Algorithms-for-Continuous-Time-Systems"><a class="docs-heading-anchor" href="#Algorithms-for-Continuous-Time-Systems">Algorithms for Continuous-Time Systems</a><a id="Algorithms-for-Continuous-Time-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-for-Continuous-Time-Systems" title="Permalink"></a></h2><ul><li><a href="#PeriodicOrbits.OptimizedShooting"><code>OptimizedShooting</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.OptimizedShooting" href="#PeriodicOrbits.OptimizedShooting"><code>PeriodicOrbits.OptimizedShooting</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizedShooting(; kwargs...)</code></pre><p>A shooting method (<a href="../references/#Dednam2014">Dednam and Botha, 2014</a>) that uses Levenberg-Marquardt optimization to find periodic orbits of continuous time dynamical systems.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Δt::Float64 = 1e-6</code>: step between the points in the residual <code>R</code>. See below for details.</li><li><code>n::Int64 = 2</code>: <code>n*dimension(ds)</code> is the number of points in the residual <code>R</code>. See below for details.</li><li><code>nonlinear_solve_kwargs = (reltol=1e-6, abstol=1e-6, maxiters=1000)</code>: keyword arguments to pass to the <code>solve</code> function from <a href="https://github.com/SciML/NonlinearSolve.jl"><code>NonlinearSolve.jl</code></a>. For details on the keywords see the respective package documentation. The algorithm we use is <code>NonlinearSolve.LevenbergMarquardt()</code>.</li></ul><p><strong>Description</strong></p><p>Let us consider the following continuous time dynamical system</p><p class="math-container">\[\frac{dx}{dt} = f(x, p, t)\]</p><p>Dednam and Botha (<a href="../references/#Dednam2014">Dednam and Botha, 2014</a>) suggest to minimize the residual <span>$R$</span> defined as</p><p class="math-container">\[R = (x(T)-x(0), x(T+\Delta t)-x(\Delta t), \dots,
x(T+(n-1)\Delta t)-x((n-1)\Delta t))\]</p><p>where <span>$T$</span> is unknown period of a periodic orbit and <span>$x(t)$</span> is a solution at time <span>$t$</span> given some unknown initial point. Initial guess of the period <span>$T$</span> and the initial point is optimized by the Levenberg-Marquardt algorithm.</p><p>In our implementation, the keyword argument <code>n</code> corresponds to <span>$n$</span> in the residual <span>$R$</span>. The keyword argument <code>Δt</code> corresponds to <span>$\Delta t$</span> in the residual <span>$R$</span>.</p><p>Note that for the algorithm to converge to a periodic orbit, the initial guess has to be close to an existing periodic orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/algorithms/continuous_time/optimized_shooting.jl#L5-L45">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.postability" href="#PeriodicOrbits.postability"><code>PeriodicOrbits.postability</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">postability(ds::CoreDynamicalSystem, po::PeriodicOrbit [, jac]) → new_po</code></pre><p>Determine the local stability of the periodic orbit <code>po</code> using the jacobian rule <code>jac</code>. Return a new periodic orbit for which <code>po.stable</code> is set to <code>true</code> if the periodic orbit is stable or <code>false</code> if it is unstable.</p><p>For discrete-time systems, the stability is determined using eigenvalues of the jacobian of <code>po.T</code>-th iterate of the dynamical system <code>ds</code> at the point <code>po.points[1]</code>. If the maximum absolute value of the eigenvalues is less than <code>1</code>, the periodic orbit is marked as stable.</p><p>For continuous-time systems, the stability is determined by the Floquet multipliers of the monodromy matrix. If the maximum absolute value of the Floquet multipliers is less than <code>1</code> (while neglecting the multiplier which is always 1), the periodic orbit is marked as stable.</p><p>The default value of jacobian rule <code>jac</code> is obtained via automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/stability.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.minimal_period" href="#PeriodicOrbits.minimal_period"><code>PeriodicOrbits.minimal_period</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimal_period(ds::DynamicalSystem, po::PeriodicOrbit; kw...) → minT_po</code></pre><p>Compute the minimal period of the periodic orbit <code>po</code> of the dynamical system <code>ds</code>. Return the periodic orbit <code>minT_po</code> with the minimal period. In the literature, minimal  period is also called prime, principal or fundamental period.</p><p><strong>Keyword arguments</strong></p><ul><li><code>atol = 1e-4</code> : After stepping the point <code>u0</code> for a time <code>T</code>, it must return to <code>atol</code> neighborhood of itself to be considered periodic.</li><li><code>maxiter = 40</code> : Maximum number of Poincare map iterations. Continuous-time systems only.  If the number of Poincare map iterations exceeds <code>maxiter</code>, but the point <code>u0</code> has not  returned to <code>atol</code> neighborhood of itself, the original period <code>po.T</code> is returned.</li><li><code>Δt = missing</code> : The time step between points in the trajectory <code>minT_po.points</code>. If <code>Δt</code>  is <code>missing</code>, then <code>Δt=minT_po.T/100</code> is used. Continuous-time  systems only. </li></ul><p><strong>Description</strong></p><p>For discrete systems, a valid period would be any natural multiple of the minimal period.  Hence, all natural divisors of the period <code>po.T</code> are checked as a potential period.  A point <code>u0</code> of the periodic orbit <code>po</code> is iterated <code>n</code> times and if the distance between  the initial point <code>u0</code> and the final point is less than <code>atol</code>, the period of the orbit  is <code>n</code>.</p><p>For continuous systems, a point <code>u0</code> of the periodic orbit is integrated for a very short  time. The resulting point <code>u1</code> is used to create a normal vector <code>a=(u1-u0)</code> to a hyperplane  perpendicular to the trajectory at <code>u0</code>. A Poincare map is created using  this hyperplane. Using the Poincare map, the hyperplane crossings are checked. Time of the  first crossing that is within <code>atol</code> distance of the initial point <code>u0</code> is the minimal  period. At most <code>maxiter</code> crossings are checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/minimal_period.jl#L5-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.podistance" href="#PeriodicOrbits.podistance"><code>PeriodicOrbits.podistance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">podistance(po1::PeriodicOrbit, po2::PeriodicOrbit, [, distance]) → Real</code></pre><p>Compute the distance between two periodic orbits <code>po1</code> and <code>po2</code>. Periodic orbits <code>po1</code> and <code>po2</code> and the dynamical system <code>ds</code> all have to be either discrete-time or continuous-time. Distance between the periodic orbits is computed using the given distance function <code>distance</code>. The default distance function is <code>StrictlyMinimumDistance(true, Euclidean())</code> which finds the minimal Euclidean distance between any pair of points where one point belongs to <code>po1</code> and the other to <code>po2</code>. For other options of the distance function, see <code>StateSpaceSets.set_distance</code>. Custom distance function can be provided as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L165-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.poequal" href="#PeriodicOrbits.poequal"><code>PeriodicOrbits.poequal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poequal(po1::PeriodicOrbit, po2::PeriodicOrbit; kwargs...) → true/false</code></pre><p>Return <code>true</code> if the periodic orbits <code>po1</code> and <code>po2</code> are approximately equal in period and in location.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Tthres=1e-3</code> : difference in periods of the periodic orbits must be less than this threshold</li><li><code>dthres=1e-3</code> : distance between periodic orbits must be less than this threshold</li><li><code>distance</code> : distance function used to compute the distance between the periodic orbits</li></ul><p>Distance between the orbits is computed using <code>podistance</code> with <code>distance</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicOrbits.uniquepos" href="#PeriodicOrbits.uniquepos"><code>PeriodicOrbits.uniquepos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniquepos(pos::Vector{&lt;:PeriodicOrbit}; atol=1e-6) → Vector{PeriodicOrbit}</code></pre><p>Return a vector of unique periodic orbits from the vector <code>pos</code> of periodic orbits. By unique we mean that the distance between any two periodic orbits in the vector is greater than <code>atol</code>. To see details about the distance function, see <a href="#PeriodicOrbits.podistance"><code>podistance</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>atol</code> : minimal distance between two periodic orbits for them to be considered unique.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L216-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.isdiscretetime" href="#DynamicalSystemsBase.isdiscretetime"><code>DynamicalSystemsBase.isdiscretetime</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdiscretetime(po::PeriodicOrbit) → true/false</code></pre><p>Return <code>true</code> if the periodic orbit belongs to a discrete-time dynamical system, <code>false</code> if it belongs to a continuous-time dynamical system. This simple function only checks whether the period is an integer or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/PeriodicOrbits.jl/blob/aa96bed58137a42bcced2d2e831f8c7b208537ae/src/api.jl#L125-L131">source</a></section><section><div><pre><code class="language-julia hljs">isdiscretetime(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if <code>ds</code> operates in discrete time, or <code>false</code> if it is in continuous time. This is information deduced from the type of <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/v3.14.0/src/core/dynamicalsystem_interface.jl#L276-L281">source</a></section></article><h2 id="Adding-new-algorithms"><a class="docs-heading-anchor" href="#Adding-new-algorithms">Adding new algorithms</a><a id="Adding-new-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-new-algorithms" title="Permalink"></a></h2><p>To implement a new periodic orbit finding algorithm, simply create a new type, make it subtype <code>PeriodicOrbitFinder</code>, and then extend the function <a href="#PeriodicOrbits.periodic_orbit"><code>periodic_orbit</code></a> for it.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Wednesday 30 April 2025 09:01">Wednesday 30 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
