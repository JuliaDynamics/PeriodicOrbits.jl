var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Dednam, W. and Botha, A. E. (2014). Optimized shooting method for finding periodic orbits of nonlinear dynamical systems.\n\n\n\n","category":"page"},{"location":"#PeriodicOrbits.jl","page":"PeriodicOrbits.jl","title":"PeriodicOrbits.jl","text":"","category":"section"},{"location":"","page":"PeriodicOrbits.jl","title":"PeriodicOrbits.jl","text":"PeriodicOrbits","category":"page"},{"location":"#PeriodicOrbits","page":"PeriodicOrbits.jl","title":"PeriodicOrbits","text":"PeriodicOrbits.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nInterface and algorithms for finding periodic orbits (stable or unstable) in dynamical systems based on the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"PeriodicOrbits\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Optimized-Shooting-Method","page":"Algorithms","title":"Optimized Shooting Method","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"OptimizedShooting","category":"page"},{"location":"algorithms/#PeriodicOrbits.OptimizedShooting","page":"Algorithms","title":"PeriodicOrbits.OptimizedShooting","text":"OptimizedShooting(; kwargs...)\n\nA shooting method (Dednam and Botha, 2014) that uses Levenberg-Marquardt optimization  to find periodic orbits of continuous-time dynamical systems.\n\nKeyword arguments\n\nΔt::Float64 = 1e-6: step between the points in the residual R. See below for details.\nn::Int64 = 2: n*dimension(ds) is the number of points in the residual R. See below  for details.\nnonlinear_solve_kwargs = (reltol=1e-6, abstol=1e-6, maxiters=1000): keyword arguments  to pass to the solve function from  NonlinearSolve.jl. For details on the  keywords see the respective package documentation.\n\nDescription\n\nLet us consider the following continuous-time dynamical system\n\nfracdxdt = f(x p t)\n\nDednam and Botha (Dednam and Botha, 2014) suggest to minimize the residual R defined as\n\nR = (x(T)-x(0) x(T+Delta t)-x(Delta t) dots \nx(T+(n-1)Delta t)-x((n-1)Delta t))\n\nwhere T is unknown period of a periodic orbit and x(t) is a solution at time t  given some unknown initial point. Initial guess of the period T and the initial point  is optimized by the Levenberg-Marquardt algorithm.\n\nIn our implementation, the keyword argument n corresponds to n in the residual R.  The keyword argument Δt corresponds to Delta t in the residual R.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Example","page":"Algorithms","title":"Example","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"using PeriodicOrbits\nusing CairoMakie\nusing OrdinaryDiffEq\n\n@inbounds function roessler_rule(u, p, t)\n    du1 = -u[2]-u[3]\n    du2 = u[1] + p[1]*u[2]\n    du3 = p[2] + u[3]*(u[1] - p[3])\n    return SVector{3}(du1, du2, du3)\nend\n\nfunction plot_result(res, ds; azimuth = 1.3 * pi, elevation = 0.3 * pi)\n    traj, t = trajectory(ds, res.T, res.points[1]; Dt = 0.01)\n    fig = Figure()\n    ax = Axis3(fig[1,1], azimuth = azimuth, elevation=elevation)\n    lines!(ax, traj[:, 1], traj[:, 2], traj[:, 3], color = :blue, linewidth=1.7)\n    scatter!(ax, res.points[1])\n    return fig\nend\n\nig = InitialGuess(SVector(2.0, 5.0, 10.0), 10.2)\nalg = OptimizedShooting(Δt=0.01, n=3)\nds = CoupledODEs(roessler_rule, [1.0, -2.0, 0.1], [0.15, 0.2, 3.5])\nres = periodic_orbit(ds, alg, ig)\nplot_result(res, ds; azimuth = 1.3pi, elevation=0.1pi)","category":"page"}]
}
